var createListN = function(N){
  //termination statement
  if(N == 1){return [1]}
  //recursion statement
  else{return createListN(N-1).concat([N])}
}

var applyProduction = function(inputString, nonTerminal, rightSide, probabilities){
  var p = sample(Categorical({ps: probabilities, vs: rightSide}))
  return inputString.replace(nonTerminal, p)
}

var firstNonTerminalIndex = function(inputString, nonTerminals){
  // takes a string and tells if it contains any non-terminal variables
  // nonTerminals is a list (which also contains "S" by default)
  var containsChar = function(char){return (inputString.indexOf(char) != -1)}
  var containsNonTerminals = map(containsChar, nonTerminals)
  var id = containsNonTerminals.indexOf(true)
  if(id == -1){return -1}
  else{return id}
}

var prog = function(inputString, nonTerminals, rightSide, probabilities){
  //This function exectues a program recursively
  var index = firstNonTerminalIndex(inputString, nonTerminals)
  // termination statement
  if(index == -1){return inputString}
  //recursion statement
  else{
    var s = applyProduction(inputString, nonTerminals[index], rightSide[index], probabilities[index])
    return prog(s, nonTerminals, rightSide, probabilities)
  }
}

var genStrings = function(progIndex){
  // model description 
  var G1 = {
    nonTerminals: ["S"],
    rightSide: [["aSb", "bSa", "a", "b"]],
    probabilities: [[0.5, 0.2, 0.1, 0.2]]
  }
  var theta = beta(0.1, 0.1)
  var G2 = {
    nonTerminals: ["S", "Y", "X"],
    rightSide: [["Xa", "bY"], ["aY", "b"], ["Xb", "a"]],
    probabilities: [[theta, 1-theta], [0.4, 0.6], [0.2, 0.8]]
  }
  var G = [G1, G2]
  
  return prog("S", G[progIndex-1].nonTerminals, G[progIndex-1].rightSide, G[progIndex-1].probabilities)
}

var dist = function(progIndex){
  var options = {method: 'MCMC', kernel: 'MH', samples: 100}  
//   var options = {method: 'SMC', particles: 200}
  return Infer(options, function(){genStrings(progIndex)})
  }

var observeString = function(progIndex, observations, N){
  //termination case
  if(N == 1){
    observe(dist(progIndex), observations[0])
    return
  }
  //recursion case
  observe(dist(progIndex), observations[N-1])
  observeString(progIndex, observations, N-1)
}

var m = function(priors, observations){
  var numProgs = priors.length
  var listOfPrograms = createListN(numProgs)
  var progIndex = sample(Categorical({ps: priors, vs: listOfPrograms}))    

  observeString(progIndex, observations, observations.length)

  return progIndex
}

var priors = [0.7, 0.3]
var observations = ["baab","bb","bb","aba","aa","bab","bab","aa","aa","aa","bb","bb","bb","bb","bab","aa","aa","aa","aa","bb"]

// repeat(20, function(){genStrings(2)})

var options = {method: 'SMC', particles: 400}
display(Infer(options, function(){m(priors, observations)}))